module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/core/contentstack.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar config = {\n    protocol: \"https\",\n    host: \"cdn.contentstack.io\",\n    port: 443,\n    version: \"v3\",\n    urls: {\n        sync: \"/stacks/sync\",\n        content_types: \"/content_types/\",\n        entries: \"/entries/\",\n        assets: \"/assets/\",\n        environments: \"/environments/\"\n    }\n};\n\nexports.default = config;\n\n//# sourceURL=webpack://Contentstack/./config.js?");

/***/ }),

/***/ "./node_modules/localStorage/lib/localStorage.js":
/*!*******************************************************!*\
  !*** ./node_modules/localStorage/lib/localStorage.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n// http://www.rajdeepd.com/articles/chrome/localstrg/LocalStorageSample.htm\n\n// NOTE:\n// this varies from actual localStorage in some subtle ways\n\n// also, there is no persistence\n// TODO persist\n(function () {\n  \"use strict\";\n\n  var db;\n\n  function LocalStorage() {}\n  db = LocalStorage;\n\n  db.prototype.getItem = function (key) {\n    if (this.hasOwnProperty(key)) {\n      return String(this[key]);\n    }\n    return null;\n  };\n\n  db.prototype.setItem = function (key, val) {\n    this[key] = String(val);\n  };\n\n  db.prototype.removeItem = function (key) {\n    delete this[key];\n  };\n\n  db.prototype.clear = function () {\n    var self = this;\n    Object.keys(self).forEach(function (key) {\n      self[key] = undefined;\n      delete self[key];\n    });\n  };\n\n  db.prototype.key = function (i) {\n    i = i || 0;\n    return Object.keys(this)[i];\n  };\n\n  db.prototype.__defineGetter__('length', function () {\n    return Object.keys(this).length;\n  });\n\n  if (global.localStorage) {\n    module.exports = localStorage;\n  } else {\n    module.exports = new LocalStorage();\n  }\n})();\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Contentstack/./node_modules/localStorage/lib/localStorage.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//# sourceURL=webpack://Contentstack/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack://Contentstack/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/core/cache-provider/index.js":
/*!******************************************!*\
  !*** ./src/core/cache-provider/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localstorage = __webpack_require__(/*! ./localstorage */ \"./src/core/cache-provider/localstorage.js\");\n\nvar _localstorage2 = _interopRequireDefault(_localstorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CacheProvider = {};\n\nCacheProvider.providers = function (provider) {\n    if (provider) {\n        return _localstorage2.default;\n    } else {\n        console.error(\"Kindly provide valid provider.\");\n    }\n};\n\nCacheProvider.policies = {\n    IGNORE_CACHE: -1,\n    ONLY_NETWORK: 0,\n    CACHE_ELSE_NETWORK: 1,\n    NETWORK_ELSE_CACHE: 2,\n    CACHE_THEN_NETWORK: 3\n};\n\nexports.default = CacheProvider;\n\n//# sourceURL=webpack://Contentstack/./src/core/cache-provider/index.js?");

/***/ }),

/***/ "./src/core/cache-provider/localstorage.js":
/*!*************************************************!*\
  !*** ./src/core/cache-provider/localstorage.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _cache = __webpack_require__(/*! ./../cache */ \"./src/core/cache.js\");\n\nvar cache = _interopRequireWildcard(_cache);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar localStorage = {};\n\nlocalStorage.get = function (key, callback) {\n    try {\n        callback(null, cache.get(key));\n    } catch (e) {\n        callback(e);\n    }\n};\n\nlocalStorage.set = function (key, value, callback) {\n    try {\n        if (key && value) cache.set(key, value);\n        callback();\n    } catch (e) {\n        callback(e);\n    }\n};\n\nfunction clearValuesForKey(keyArray, append) {\n    if (!append && keyArray && keyArray.length) keyArray.push('');\n    var _key = void 0,\n        keys = cache.getKeys(),\n        storage = cache.getStorage();\n    if (!keyArray || !keyArray.length) {\n        for (var i = 0, _i = keys.length; i < _i; i++) {\n            delete storage[keys[i]];\n        }\n    } else {\n        _key = keyArray.join('.');\n        for (var _i2 = 0, _i3 = keys.length; _i2 < _i3; _i2++) {\n            if (keys[_i2] && keys[_i2].indexOf(_key) === 0) delete storage[keys[_i2]];\n        }\n    }\n}\n\nlocalStorage.clearByContentType = function () {\n    try {\n        if (arguments.length === 2 || arguments.length === 3) {\n            var args = Array.prototype.slice.call(arguments);\n            var _callback = args.splice(-1, 1).pop();\n            var valueArray = [];\n            valueArray.push.apply(valueArray, args);\n            clearValuesForKey(valueArray);\n            _callback();\n        }\n    } catch (e) {\n        callback(e);\n    }\n};\n\nlocalStorage.clearByQuery = function (query, callback) {\n    try {\n        var keys = cache.getKeys(),\n            storage = cache.getStorage();\n        for (var i = 0, _i = keys.length; i < _i; i++) {\n            if (keys[i] && ~keys[i].indexOf(query)) delete storage[keys[i]];\n        }\n        callback();\n    } catch (e) {\n        callback(e);\n    }\n};\n\nlocalStorage.clearAll = function (callback) {\n    try {\n        clearValuesForKey();\n        callback();\n    } catch (e) {\n        callback(e);\n    }\n};\n\nexports.default = localStorage;\n\n//# sourceURL=webpack://Contentstack/./src/core/cache-provider/localstorage.js?");

/***/ }),

/***/ "./src/core/cache.js":
/*!***************************!*\
  !*** ./src/core/cache.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.get = get;\nexports.set = set;\nexports.getStorage = getStorage;\nexports.getKeys = getKeys;\n\nvar _utils = __webpack_require__(/*! ./lib/utils.js */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _localstorage = __webpack_require__(/*! runtime/localstorage.js */ \"./src/runtime/react-native/localstorage.js\");\n\nvar _localstorage2 = _interopRequireDefault(_localstorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction get(key) {\n    var data = _localstorage2.default.getItem(key);\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        return data;\n    }\n    return data || null;\n};\n\nfunction set(key, data) {\n    try {\n        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            _localstorage2.default.setItem(key, JSON.stringify(data));\n        } else {\n            _localstorage2.default.setItem(key, data);\n        }\n    } catch (error) {}\n};\n\nfunction getStorage() {\n    return _localstorage2.default || null;\n};\n\nfunction getKeys() {\n    return _localstorage2.default ? Object.keys(_localstorage2.default) : [];\n};\n\n//# sourceURL=webpack://Contentstack/./src/core/cache.js?");

/***/ }),

/***/ "./src/core/contentstack.js":
/*!**********************************!*\
  !*** ./src/core/contentstack.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _stack = __webpack_require__(/*! ./stack */ \"./src/core/stack.js\");\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _index = __webpack_require__(/*! ./cache-provider/index */ \"./src/core/cache-provider/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _contentstackregion = __webpack_require__(/*! ./contentstackregion */ \"./src/core/contentstackregion.js\");\n\nvar _contentstackregion2 = _interopRequireDefault(_contentstackregion);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* @class \n Contentstack \n* @description Creates an instance of `Contentstack`.\n* @instance\n*/\n\nvar Contentstack = function () {\n\tfunction Contentstack() {\n\t\t_classCallCheck(this, Contentstack);\n\n\t\t/**\n   * @memberOf Contentstack\n   * @description CachePolicy contains different cache policies constants.\n   * @example\n   * Contentstack.CachePolicy.IGNORE_CACHE\n   * Contentstack.CachePolicy.ONLY_NETWORK\n   * Contentstack.CachePolicy.CACHE_ELSE_NETWORK\n   * Contentstack.CachePolicy.NETWORK_ELSE_CACHE\n   * Contentstack.CachePolicy.CACHE_THEN_NETWORK\n   */\n\t\tthis.CachePolicy = _index2.default.policies;\n\t\tthis.Region = _contentstackregion2.default;\n\t}\n\t/**\n \n * @memberOf Contentstack\n */\n\n\n\t_createClass(Contentstack, [{\n\t\tkey: \"Stack\",\n\t\tvalue: function Stack() {\n\t\t\tfor (var _len = arguments.length, stack_arguments = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\tstack_arguments[_key] = arguments[_key];\n\t\t\t}\n\n\t\t\treturn new (Function.prototype.bind.apply(_stack2.default, [null].concat(stack_arguments)))();\n\t\t}\n\t}]);\n\n\treturn Contentstack;\n}();\n\nmodule.exports = new Contentstack();\n\n//# sourceURL=webpack://Contentstack/./src/core/contentstack.js?");

/***/ }),

/***/ "./src/core/contentstackregion.js":
/*!****************************************!*\
  !*** ./src/core/contentstackregion.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar ContentstackRegion = {\n    EU: \"eu\",\n    US: \"us\"\n};\n\nexports.default = ContentstackRegion;\n//module.exports = ContentstackRegion;\n\n//# sourceURL=webpack://Contentstack/./src/core/contentstackregion.js?");

/***/ }),

/***/ "./src/core/lib/request.js":
/*!*********************************!*\
  !*** ./src/core/lib/request.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = Request;\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _http = __webpack_require__(/*! runtime/http.js */ \"./src/runtime/react-native/http.js\");\n\nvar _http2 = _interopRequireDefault(_http);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n//JS SDK version\nvar version = '3.12.0';\nvar environment = void 0,\n    api_key = void 0;\nfunction Request(options, fetchOptions) {\n    return new Promise(function (resolve, reject) {\n        var queryParams = void 0;\n        var serialize = function serialize(obj, prefix) {\n\n            var str = [],\n                p = void 0;\n            if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" && obj.length !== undefined) {\n                for (var i = 0, _i = obj.length; i < _i; i++) {\n                    str.push(prefix + '[]=' + obj[i]);\n                }\n            } else {\n                for (p in obj) {\n                    var k = prefix ? prefix + \"[\" + p + \"]\" : p,\n                        v = obj[p];\n                    str.push(v !== null && (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && p !== 'query' ? serialize(v, k) : k + \"=\" + encodeURIComponent(p !== 'query' ? v : JSON.stringify(v)));\n                }\n            }\n            return str.join(\"&\");\n        };\n\n        var url = options.url,\n            headers = options.headers;\n\n        // setting headers\n        headers['Content-Type'] = 'application/json; charset=UTF-8';\n        headers['X-User-Agent'] = 'contentstack-react-native/' + version;\n\n        if (options.body && _typeof(options.body) === 'object') {\n            delete options.body._method;\n            if (_typeof(options.body.query) === \"object\" && Object.keys(options.body.query).length === 0) delete options.body.query;\n            queryParams = serialize(options.body);\n        }\n\n        return fetchRetry(url + '?' + queryParams, headers, fetchOptions.retryDelay, fetchOptions.retryLimit, fetchOptions, resolve, reject);\n    });\n}\n\nfunction wait(retryDelay) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, retryDelay);\n    });\n}\n\nfunction fetchRetry(url, headers) {\n    var retryDelay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n    var retryLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n    var fetchOptions = arguments[4];\n    var resolve = arguments[5];\n    var reject = arguments[6];\n\n    var option = Object.assign({\n        method: 'GET',\n        headers: headers,\n        timeout: 3000\n    }, fetchOptions);\n\n    function onError(error) {\n        if (retryLimit === 0) {\n            reject(error);\n        } else {\n            var msDelay = retryDelay;\n            retryLimit = retryLimit - 1;\n            var retryCount = fetchOptions.retryLimit - retryLimit;\n            if (fetchOptions.retryDelayOptions) {\n                if (fetchOptions.retryDelayOptions.base) {\n                    msDelay = fetchOptions.retryDelayOptions.base * retryCount;\n                } else if (fetchOptions.retryDelayOptions.customBackoff) {\n                    msDelay = fetchOptions.retryDelayOptions.customBackoff(retryCount, error);\n                }\n            }\n            wait(msDelay).then(function () {\n                return fetchRetry(url, headers, retryDelay, retryLimit, fetchOptions, resolve, reject);\n            });\n        }\n    }\n    (0, _http2.default)(url, option).then(function (response) {\n        var data = response.json();\n        if (response.ok && response.status === 200) {\n            resolve(data);\n        } else {\n            data.then(function (json) {\n                if (fetchOptions.retryCondition && fetchOptions.retryCondition(response)) {\n                    onError(json);\n                } else {\n                    reject(json);\n                }\n            });\n        }\n    }).catch(function (error) {\n        reject(error);\n    });\n}\n\n//# sourceURL=webpack://Contentstack/./src/core/lib/request.js?");

/***/ }),

/***/ "./src/core/lib/utils.js":
/*!*******************************!*\
  !*** ./src/core/lib/utils.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.transform = transform;\nexports._type = _type;\nexports.mergeDeep = mergeDeep;\nexports.merge = merge;\nexports.isBrowser = isBrowser;\nexports.parseQueryFromParams = parseQueryFromParams;\nexports.getHash = getHash;\nexports.generateHash = generateHash;\nexports.resultWrapper = resultWrapper;\nexports.spreadResult = spreadResult;\nexports.sendRequest = sendRequest;\n\nvar _request = __webpack_require__(/*! ./request */ \"./src/core/lib/request.js\");\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _result = __webpack_require__(/*! ../modules/result */ \"./src/core/modules/result.js\");\n\nvar _result2 = _interopRequireDefault(_result);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @method addSpread\n * @description method to add the spread.\n */\n(function addSpread() {\n    if (Promise.prototype.spread) return;\n    Promise.prototype.spread = function (fn, errFunc) {\n        errFunc = errFunc || function (err) {};\n        return this.then(function (args) {\n            return fn.apply(fn, args);\n        }).catch(function (err) {\n            errFunc(err);\n        });\n    };\n})();\n\nfunction transform(type) {\n    return function () {\n        this._query[type] = this._query[type] || {};\n        switch (arguments.length) {\n            case 1:\n                if (Array.isArray(arguments[0]) || typeof arguments[0] === \"string\") {\n                    var query = this._query[type]['BASE'] || [];\n                    query = query.concat(arguments[0]);\n                    this._query[type]['BASE'] = query;\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid parameters\");\n                }\n                break;\n            case 2:\n                if (typeof arguments[0] === \"string\" && (Array.isArray(arguments[1]) || typeof arguments[1] === \"string\")) {\n                    var _query2 = this._query[type][arguments[0]] || [];\n                    _query2 = _query2.concat(arguments[1]);\n                    this._query[type][arguments[0]] = _query2;\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid parameters\");\n                }\n                break;\n            default:\n                console.error(\"Kindly provide valid parameters\");\n        }\n    };\n}\n\nfunction _type(val) {\n    var _typeof = void 0,\n        __typeof = typeof val === 'undefined' ? 'undefined' : _typeof2(val);\n    switch (__typeof) {\n        case 'object':\n            _typeof = __typeof;\n            if (Array.isArray(val)) {\n                __typeof = 'array';\n            }\n            break;\n        default:\n            _typeof = __typeof;\n    }\n    return __typeof;\n};\n\n// merge two objects\nfunction mergeDeep(target, source) {\n    var self = this;\n    var _merge_recursive = function _merge_recursive(target, source) {\n        for (var key in source) {\n            if (self._type(source[key]) == 'object' && self._type(target[key]) == self._type(source[key])) {\n                _merge_recursive(target[key], source[key]);\n            } else if (self._type(source[key]) == 'array' && self._type(target[key]) == self._type(source[key])) {\n                target[key] = target[key].concat(source[key]);\n            } else {\n                target[key] = source[key];\n            }\n        }\n    };\n    _merge_recursive(target, source);\n    return target;\n};\n\n// merge two objects\nfunction merge(target, source) {\n    if (target && source) {\n        for (var key in source) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n};\n\n// return true if process is running in browser else false\nfunction isBrowser() {\n    return typeof window !== \"undefined\" && (typeof process === 'undefined' ? 'undefined' : _typeof2(process)) === \"object\" && process.title === \"browser\";\n};\n\n// return the query from the params\nfunction parseQueryFromParams(queryObject, single, toJSON) {\n    if (queryObject && queryObject.requestParams) {\n        var _query = merge({}, queryObject.requestParams.body ? queryObject.requestParams.body.query || {} : {});\n        if (_query.environment_uid) {\n            delete _query.environment_uid;\n            _query.environment = queryObject.environment;\n        }\n        _query.environment = queryObject.environment;\n        return {\n            content_type_uid: queryObject.content_type_uid,\n            locale: _query.locale || 'en-us',\n            query: _query,\n            entry_uid: queryObject.entry_uid,\n            asset_uid: queryObject.asset_uid,\n            single: single || \"false\",\n            toJSON: toJSON || \"false\",\n            api_key: queryObject.requestParams.headers ? queryObject.requestParams.headers.api_key : \"\"\n        };\n    }\n};\n\n// returrn the hash value of the query\nfunction getHash(query) {\n    try {\n        var hashValue = generateHash(JSON.stringify(query)),\n            keyArray = [];\n        keyArray.push(query.content_type_uid);\n        keyArray.push(query.locale);\n        if (query.entry_uid) keyArray.push(query.entry_uid);\n        if (query.asset_uid) keyArray.push(query.asset_uid);\n        keyArray.push(hashValue);\n        return keyArray.join('.');\n    } catch (e) {}\n};\n\n// return the hash value of the string\nfunction generateHash(str) {\n    var hash = 0,\n        i = void 0,\n        chr = void 0,\n        len = void 0;\n    if (str.length === 0) return hash;\n    for (i = 0, len = str.length; i < len; i++) {\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash < -1 ? hash * -1 : hash;\n};\n\n// generate the Result object\nfunction resultWrapper(result) {\n    if (result && typeof result.entries !== 'undefined') {\n        if (result.entries && result.entries.length) {\n            for (var i = 0, _i = result.entries.length; i < _i; i++) {\n                result.entries[i] = (0, _result2.default)(result.entries[i]);\n            }\n        } else {\n            result.entries = [];\n        }\n    } else if (result && result.assets && typeof result.assets !== 'undefined') {\n        if (result.assets && result.assets.length) {\n            for (var j = 0, _j = result.assets.length; j < _j; j++) {\n                result.assets[j] = (0, _result2.default)(result.assets[j]);\n            }\n        } else {\n            result.assets = [];\n        }\n    } else if (result && typeof result.entry !== 'undefined') {\n        result.entry = (0, _result2.default)(result.entry);\n    } else if (result && typeof result.asset !== 'undefined') {\n        result.asset = (0, _result2.default)(result.asset);\n    } else if (result && typeof result.items !== 'undefined') {\n        result.items = (0, _result2.default)(result.items).toJSON();\n    }\n\n    return result;\n};\n\n// // spread the result object\n// export function spreadResult(result) {\n//     let _results = [];\n//     if (result && Object.keys(result).length) {\n//         if (typeof result.entries !== 'undefined') _results.push(result.entries);\n//         if (typeof result.assets !== 'undefined') _results.push(result.assets);\n//         if (typeof result.content_type !== 'undefined' || typeof result.schema !== 'undefined') _results.push(result.content_type || result.schema);\n//         if (typeof result.count !== 'undefined') _results.push(result.count);\n//         if (typeof result.entry !== 'undefined') _results = result.entry;\n//         if (typeof result.asset !== 'undefined') _results = result.asset;\n//         if (typeof result.items !== 'undefined') _results.push(result);\n//     }\n//     return _results;\n// };\n\n// spread the result object\nfunction spreadResult(result) {\n    var _results = [];\n    if (result && Object.keys(result).length) {\n        if (typeof result.entries !== 'undefined') {\n            _results.push(result.entries);\n            if (result.content_type) {\n                _results['schema'] = result.content_type;\n            }\n        }\n        if (typeof result.assets !== 'undefined') _results.push(result.assets);\n        if (typeof result.content_type !== 'undefined' || typeof result.schema !== 'undefined') _results.push(result.content_type || result.schema);\n        if (typeof result.count !== 'undefined') _results.push(result.count);\n        if (typeof result.entry !== 'undefined') {\n            _results = result.entry;\n            if (result.schema) {\n                _results['schema'] = result.schema;\n            }\n            if (result.content_type) {\n                _results['content_type'] = result.content_type;\n            }\n        }\n        if (typeof result.asset !== 'undefined') _results = result.asset;\n        if (typeof result.items !== 'undefined') _results.push(result);\n    }\n    return _results;\n};\n\nfunction sendRequest(queryObject, options) {\n\n    var env_uid = queryObject.environment_uid;\n    if (env_uid) {\n        queryObject._query.environment_uid = env_uid;\n    } else {\n        if (queryObject._query) {\n            queryObject._query.environment = queryObject.environment;\n        } else {\n            queryObject['_query'] = {};\n            queryObject._query['environment'] = queryObject.environment;\n        }\n    }\n\n    var self = queryObject;\n    var continueFlag = false;\n    var cachePolicy = typeof self.queryCachePolicy !== 'undefined' ? self.queryCachePolicy : self.cachePolicy;\n    var tojson = typeof self.tojson !== 'undefined' ? self.tojson : false;\n    var isSingle = self.entry_uid || self.singleEntry || self.asset_uid ? true : false;\n    var hashQuery = getHash(parseQueryFromParams(self, isSingle, tojson));\n\n    /**\n    for new api v3\n    */\n    if (queryObject && queryObject.requestParams && queryObject.requestParams.body && queryObject.requestParams.body.query) {\n        var cloneQueryObj = JSON.parse(JSON.stringify(queryObject.requestParams.body.query));\n        if ((typeof cloneQueryObj === 'undefined' ? 'undefined' : _typeof2(cloneQueryObj)) !== 'object') {\n            cloneQueryObj = JSON.parse(cloneQueryObj);\n        }\n        delete queryObject.requestParams.body.query;\n        queryObject.requestParams.body = merge(queryObject.requestParams.body, cloneQueryObj);\n    }\n\n    var getCacheCallback = function getCacheCallback() {\n        return function (err, entries) {\n            return new Promise(function (resolve, reject) {\n                try {\n                    if (err) throw err;\n                    if (!tojson) entries = resultWrapper(entries);\n                    resolve(spreadResult(entries));\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        };\n    };\n\n    var callback = function callback(continueFlag, resolve, reject) {\n        if (continueFlag) {\n            (0, _request2.default)(queryObject.requestParams, options).then(function (data) {\n                try {\n                    self.entry_uid = self.asset_uid = self.tojson = self.queryCachePolicy = undefined;\n                    var entries = {};\n                    var syncstack = {};\n                    if (queryObject.singleEntry) {\n                        queryObject.singleEntry = false;\n                        if (data.schema) entries.schema = data.schema;\n                        if (data.content_type) {\n                            entries.content_type = data.content_type;\n                            delete entries.schema;\n                        }\n                        if (data.entries && data.entries.length) {\n                            entries.entry = data.entries[0];\n                        } else if (data.assets && data.assets.length) {\n                            entries.assets = data.assets[0];\n                        } else {\n                            if (cachePolicy === 2 && self.provider !== null) {\n                                self.provider.get(hashQuery, getCacheCallback());\n                            } else {\n                                return reject({ error_code: 141, error_message: 'The requested entry doesn\\'t exist.' });\n                            }\n                            return;\n                        }\n                    } else if (data.items) {\n                        syncstack = {\n                            items: data.items,\n                            pagination_token: data.pagination_token,\n                            sync_token: data.sync_token,\n                            total_count: data.total_count\n                        };\n                    } else {\n                        entries = data;\n                    }\n\n                    if (cachePolicy !== -1 && self.provider !== null) {\n                        self.provider.set(hashQuery, entries, function (err) {\n                            try {\n                                if (err) throw err;\n                                if (!tojson) entries = resultWrapper(entries);\n                                return resolve(spreadResult(entries));\n                            } catch (e) {\n                                return reject(e);\n                            }\n                        });\n                        return resolve(spreadResult(entries));\n                    }\n\n                    if (Object.keys(syncstack).length) {\n                        return resolve(syncstack);\n                    }\n\n                    if (!tojson) entries = resultWrapper(entries);\n                    return resolve(spreadResult(entries));\n                } catch (e) {\n                    return reject({\n                        message: e.message\n                    });\n                }\n            }.bind(self)).catch(function (error) {\n                if (cachePolicy === 2 && self.provider !== null) {\n                    self.provider.get(hashQuery, getCacheCallback());\n                } else {\n                    return reject(error);\n                }\n            });\n        }\n    };\n    switch (cachePolicy) {\n        case 1:\n            return new Promise(function (resolve, reject) {\n                if (self.provider !== null) {\n                    self.provider.get(hashQuery, function (err, _data) {\n                        try {\n                            if (err || !_data) {\n                                callback(true, resolve, reject);\n                            } else {\n                                if (!tojson) _data = resultWrapper(_data);\n                                return resolve(spreadResult(_data));\n                            }\n                        } catch (e) {\n                            return reject(e);\n                        }\n                    });\n                } else {\n                    callback(true, resolve, reject);\n                }\n            });\n            break;\n        case 2:\n        case 0:\n        case undefined:\n        case -1:\n            return new Promise(function (resolve, reject) {\n                callback(true, resolve, reject);\n            });\n    };\n\n    if (cachePolicy === 3) {\n\n        var promise = new Promise(function (resolve, reject) {\n            if (self.provider !== null) {\n                self.provider.get(hashQuery, function (err, _data) {\n                    try {\n                        if (err || !_data) {\n                            reject(err);\n                            //reject(Error(\"It broke\"));\n                        } else {\n                            if (!tojson) _data = resultWrapper(_data);\n                            resolve(spreadResult(_data));\n                        }\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }\n        });\n\n        return promise.then(function () {\n            return new Promise(function (resolve, reject) {\n                callback(true, resolve, reject);\n            });\n        }).catch(function (error) {\n            return new Promise(function (resolve, reject) {\n                callback(true, resolve, reject);\n            });\n            console.error(error);\n        });\n    }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Contentstack/./src/core/lib/utils.js?");

/***/ }),

/***/ "./src/core/modules/assets.js":
/*!************************************!*\
  !*** ./src/core/modules/assets.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ../lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _stack = __webpack_require__(/*! ../stack */ \"./src/core/stack.js\");\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _query = __webpack_require__(/*! ./query */ \"./src/core/modules/query.js\");\n\nvar _query2 = _interopRequireDefault(_query);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class \n  Assets  \n* @summary Creates an instance of `Assets`.\n* @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.\n* @param {String} uid - uid of asset you want to retrieve\n* @example \n* let data = Stack.Assets('bltsomething123').toJSON().fetch()\n*      data\n*      .then(function(result) {\n*           // ‘result’ is a single asset object of specified uid       \n*      }, function(error) {\n*           // error function\n*      })\n* @example \n* // Retrieves all assets*\n* let data = Stack.Assets().Query().toJSON().find()\n*      data\n*      .then(function(result) {\n*          // All the asset with limit of 100\n*          // Use skip and limit functions to paginate\n*          // ‘result’ will display all assets present in stack       \n*      }, function(error) {\n*           // error function\n*      })\n* @returns {Assets}\n* @instance\n*/\n\nvar Assets = function () {\n    function Assets() {\n        _classCallCheck(this, Assets);\n\n        this._query = {};\n        this.only = Utils.transform('only');\n        return this;\n    }\n\n    /**\n      * Converts your response into plain JavasScript object\n      * @memberOf Assets\n      * @example var Query = Stack.ContentType('blog').Query()\n       Query   \n            .toJSON()\n            .find()\n            .then(function (result) {\n                // 'result' is an object which content the data in json object form\n             },function (error) {\n                // error function\n        })\n      * @returns {Assets}\n      * @instance\n      */\n\n    _createClass(Assets, [{\n        key: 'toJSON',\n        value: function toJSON() {\n            this.tojson = true;\n            return this;\n        }\n\n        /**\n           * Includes query parameters in your queries.\n           * @memberOf Assets\n           * @example var data = Stack.Assets(assetUid).addParam('include_dimension', 'true').toJSON().fetch()\n             *      data.then(function (result) {\n             *          // 'result' is an object which content the data including count in json object form\n             *       },function (error) {\n             *          // error function\n             *      })\n             * @returns {Assets}\n             * @instance\n           */\n\n    }, {\n        key: 'addParam',\n        value: function addParam(key, value) {\n            if (key && typeof key === 'string' && value && typeof value === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide a valid parameters.\");\n            }\n        }\n\n        /**\n         * @method includeFallback\n         * @memberOf Entry\n         * @description Include the fallback locale publish content, if specified locale content is not publish.\n         * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeFallback().fetch()\n         * @returns {Asset}\n         * @instance\n         */\n\n    }, {\n        key: 'includeFallback',\n        value: function includeFallback() {\n            this._query['include_fallback'] = true;\n            return this;\n        }\n\n        /**\n           * Fetches a particular asset based on the provided asset UID.\n           * @memberOf Assets\n           * @example\n           * Stack.Assets('assets_uid').toJSON().fetch()\n           * @example\n           * Stack.Assets('assets_uid').toJSON().fetch({\n           *         \n           *      })\n           * @returns {promise}\n           * @instance\n           */\n\n    }, {\n        key: 'fetch',\n        value: function fetch(fetchOptions) {\n            if (this.asset_uid) {\n                this.requestParams = {\n                    method: 'POST',\n                    headers: this.headers,\n                    url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.assets + this.asset_uid,\n                    body: {\n                        _method: 'GET',\n                        query: this._query\n                    }\n                };\n                var options = Object.assign({}, this.fetchOptions, fetchOptions);\n                return Utils.sendRequest(this, options);\n            } else {\n                console.error(\"Kindly provide an asset uid. e.g. .Assets('bltsomething123')\");\n            }\n        }\n    }]);\n\n    return Assets;\n}();\n\nexports.default = Assets;\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/assets.js?");

/***/ }),

/***/ "./src/core/modules/entry.js":
/*!***********************************!*\
  !*** ./src/core/modules/entry.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ../lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _stack = __webpack_require__(/*! ../stack */ \"./src/core/stack.js\");\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class \n  Entry \n* @summary Creates an instance of `Entry`.   \n* @description An initializer is responsible for creating Entry object.\n* @param {String} uid - uid of the entry\n* @example\n* let Entry = Stack.ContentType('example').Entry('entry_uid');\n* @returns {Entry}\n* @instance\n*/\n\nvar Entry = function () {\n    function Entry() {\n        _classCallCheck(this, Entry);\n\n        this._query = {};\n        /**\n         * @method only\n         * @memberOf Entry\n         * @description Displays values of only the specified fields of entries or assets in the response\n         * @param {String} [key=BASE] -  Assets: </br>\n         *                                <p>Retrieves specified field of asset</p>\n         * @param {String}            -  Entries:</br>\n         *                                       <p>- retrieves default fields of the schema.</p>\n         *                                       <p>- referenced_content-type-uid : retrieves fields of the referred content type.</p>\n         * @param {Array} values - array of fields that you want to display in the response\n         * @example\n         * <caption> The only function with field_uid will include the data of only the specified fields for each entry and exclude the data of all other fields. </caption>\n         * Stack.ContentType('contentTypeUid').Query().only('title').toJSON().find()\n         * \n         * <caption> The only function with an array of field_uids will include multiple fields for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().only(['title','description']).toJSON().find()\n         * \n         * <caption> In only, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter to include the data of only the specified field_uid for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid','title').toJSON().find()\n         * \n         * <caption> In only, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter with an array of fields to include the data of only the specified array of field_uids for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid', ['title', 'description']).toJSON().find()\n         * \n         * @returns {Entry}\n         * @instance\n         */\n        this.only = Utils.transform('only');\n        /**\n         * @method except\n         * @memberOf Entry\n         * @description Displays all data of an entries or assets excluding the data of the specified fields.\n         * @param {String} [key=BASE] - BASE (default value) - retrieves default fields of the schema.\n                                                             - referenced_content-type-uid - retrieves fields of the referred content type.\n         * @param {Array} values - array of fields that you want to skip in the response\n         * @example\n         * <caption> The except function with field_uid will exclude the data of only the specified fields for each entry and includes the data of all other fields. </caption>\n         * Stack.ContentType('contentTypeUid').Query().except('title').toJSON().find()\n         * @example\n         * <caption> The except function with an array of field_uids will except multiple fields for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().except(['title','description']).toJSON().find()\n         * @example\n         * <caption> In except, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter to except the data of only the specified field_uid for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid','title').toJSON().find()\n         * @example\n         * <caption> In except, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter with an array of fields to except the data of only the specified array of field_uids for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid', ['title', 'description']).toJSON().find()\n         * @returns {Entry}\n         * @instance \n         */\n        this.except = Utils.transform('except');\n        return this;\n    }\n\n    _createClass(Entry, [{\n        key: \"setCacheProvider\",\n        value: function setCacheProvider(provider) {\n            if (provider && (typeof provider === \"undefined\" ? \"undefined\" : _typeof(provider)) === 'object') {\n                this.provider = provider;\n            }\n            return this;\n        }\n    }, {\n        key: \"setCachePolicy\",\n        value: function setCachePolicy(policy) {\n            if (typeof policy === 'number' && policy >= -1 && policy < 4) {\n                if (!this._query) {\n                    this.cachePolicy = policy;\n                } else {\n                    this.queryCachePolicy = policy;\n                }\n            } else {\n                console.error(\"Kindly provide the valid policy\");\n            }\n            return this;\n        }\n\n        /**\n            * @method includeReference\n            * @memberOf Entry\n            * @description Fetches the entire content of referenced entry(ies). <a href='https://www.contentstack.com/docs/developers/apis/content-delivery-api/#include-reference'>Read More</a>\n            * @example\n            * <caption> .includeReference with reference_field_uids as array </caption>\n            * var Query = Stack.ContentType(contentTypes.source).Query();\n                   Query\n                       .includeReference(['reference_field_uid', 'other_reference_field_uid'])\n                       .toJSON()\n                       .find()\n                       .then(function success(entries) {\n                           //'entries' is  an object used to retrieve data including reference entries.\n                       })\n            * @example\n            * <caption> .includeReference with reference_field_uids and its children reference </caption>\n            * var Query = Stack.ContentType(contentTypes.source).Query();\n                   Query\n                       .includeReference(['reference_field_uid', 'reference_field_uid.child_reference_field_uid'])\n                       .toJSON()\n                       .find()\n                       .then(function success(entries) {\n                           //'entries' is  an object used to retrieve data including reference entries.\n                       })\n            * @example\n            * <caption> .includeReference with reference_field_uids </caption>\n            * var Query = Stack.ContentType(contentTypes.source).Query(); \n            Query\n               .includeReference('reference_field_uid')\n               .toJSON()\n               .find()\n               .then(function success(entries) {\n                   //'entries' is  an object used to retrieve data including particular reference using reference_uid.\n               })\n            * @returns {Entry}\n            * @instance\n            */\n\n    }, {\n        key: \"includeReference\",\n        value: function includeReference() {\n            for (var _len = arguments.length, val = Array(_len), _key = 0; _key < _len; _key++) {\n                val[_key] = arguments[_key];\n            }\n\n            if (Array.isArray(val) || typeof val === \"string\") {\n                if (arguments.length) {\n                    for (var i = 0; i < arguments.length; i++) {\n                        this._query['include'] = this._query['include'] || [];\n                        this._query['include'] = this._query['include'].concat(arguments[i]);\n                    }\n                }\n                return this;\n            } else {\n                console.error(\"Argument should be a String or an Array.\");\n            }\n        }\n\n        /**\n        * Sets the language code of which you want to retrieve data.\n        * @param {String} language_code - language code. e.g. 'en-us', 'ja-jp', etc.\n        * @memberOf Entry\n        * @example \n        * let data = Stack.ContentType(contentTypeUid).Entry(entryUid).language('ja-jp').fetch()\n        * data\n        *      .then(function(result) {\n        *           // 'result' is  an object used to retrieve data of ja-jp language.\n        *      }, function(error) {\n        *           // error function\n        *      })\n        *          \n        * @returns {Entry}\n        * @instance\n        */\n\n    }, {\n        key: \"language\",\n        value: function language(language_code) {\n            if (language_code && typeof language_code === 'string') {\n                this._query['locale'] = language_code;\n                return this;\n            } else {\n                console.error(\"Argument should be a String.\");\n            }\n        }\n\n        /**\n        * @method addQuery\n        * @memberOf Entry\n        * @description Adds query to Entry object\n        * @param {String} key - key of the query\n        * @param {String} value - value of the query\n        * @example Stack.ContentType(contentTypeUid).Entry(entry_uid).addQuery('include_schema',true)\n        * @returns {Entry}\n        * @instance\n        */\n\n    }, {\n        key: \"addQuery\",\n        value: function addQuery(key, value) {\n            if (key && value && typeof key === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"First argument should be a String.\");\n            }\n        }\n\n        /**\n         * @method includeSchema\n         * @memberOf Entry\n         * @deprecated since verion 3.3.0\n         * @description  Include schema of the current content type along with entry/entries details.\n         * @example Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeSchema().fetch()\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeSchema\",\n        value: function includeSchema() {\n            this._query['include_schema'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeReferenceContentTypeUid\n         * @memberOf Entry\n         * @description  This method also includes the content type UIDs of the referenced entries returned in the response.\n         * @example Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeReferenceContentTypeUID().fetch()\n         * @example \n         * Query = Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeReferenceContentTypeUID().fetch()\n         * Query\n         *      .toJSON()\n         *      .then(function (result) {\n         *          let value = result.get(field_uid)\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeReferenceContentTypeUID\",\n        value: function includeReferenceContentTypeUID() {\n            this._query['include_reference_content_type_uid'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeFallback\n         * @memberOf Entry\n         * @description Include the fallback locale publish content, if specified locale content is not publish.\n         * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeFallback().fetch()\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeFallback\",\n        value: function includeFallback() {\n            this._query['include_fallback'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeContentType\n         * @memberOf Entry\n         * @description Include the details of the content type along with the entry/entries details.\n         * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeContentType().fetch()\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeContentType\",\n        value: function includeContentType() {\n            this._query['include_content_type'] = true;\n            return this;\n        }\n\n        /**\n          * @method includeOwner\n          * @memberOf Entry \n          * @description Includes the owner details of the entry/entries\n          * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeOwner().fetch()\n          * @returns {Entry}\n          * @instance\n          */\n\n    }, {\n        key: \"includeOwner\",\n        value: function includeOwner() {\n            this._query['include_owner'] = true;\n            return this;\n        }\n\n        /**\n         * @method toJSON\n         * @memberOf Entry \n         * @description Converts your response into plain JavasScript object.Supports both entry and asset queries.\n         * @example\n         * Query = Stack.ContentType(contentTypeUid).Entry(entryUid).fetch()\n         * Query\n         *      .toJSON()\n         *      .then(function (result) {\n         *          let value = result.get(field_uid)\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            this.tojson = true;\n            return this;\n        }\n\n        /**\n         * @method addParam\n         * @memberOf Entry \n         * @description Includes query parameters in your queries.\n         * @example var data = Stack.ContentType(contentTypeUid).Entry(entryUid).addParam('include_count', 'true').fetch()\n         *      data.then(function (result) {\n         *          // 'result' is an object which content the data including count in json object form\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"addParam\",\n        value: function addParam(key, value) {\n            if (key && value && typeof key === 'string' && typeof value === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n        * @method fetch\n        * @memberOf Entry \n        * @description Fetches a particular entry based on the provided entry UID.\n        * @example\n        * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch()\n        * \n        * @example\n        * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch({\n        *         \n        *      })\n        * @returns {promise}\n        * @instance\n        */\n\n    }, {\n        key: \"fetch\",\n        value: function fetch(fetchOptions) {\n            if (this.entry_uid) {\n                this.requestParams = {\n                    method: 'POST',\n                    headers: this.headers,\n                    url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries + this.entry_uid,\n                    body: {\n                        _method: 'GET',\n                        query: this._query\n                    }\n                };\n                var options = Object.assign({}, this.fetchOptions, fetchOptions);\n                return Utils.sendRequest(this, options);\n            } else {\n                console.error(\"Kindly provide an entry uid. e.g. .Entry('bltsomething123')\");\n            }\n        }\n    }]);\n\n    return Entry;\n}();\n\nexports.default = Entry;\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/entry.js?");

/***/ }),

/***/ "./src/core/modules/query.js":
/*!***********************************!*\
  !*** ./src/core/modules/query.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _request = __webpack_require__(/*! ../lib/request */ \"./src/core/lib/request.js\");\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _utils = __webpack_require__(/*! ../lib/utils.js */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _entry = __webpack_require__(/*! ./entry */ \"./src/core/modules/entry.js\");\n\nvar _entry2 = _interopRequireDefault(_entry);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _extend = {\n    compare: function compare(type) {\n        return function (key, value) {\n            if (key && value && typeof key === 'string' && typeof value !== 'undefined') {\n                this._query['query'][key] = this._query['query']['file_size'] || {};\n                this._query['query'][key][type] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        };\n    },\n    contained: function contained(bool) {\n        var type = bool ? '$in' : '$nin';\n        return function (key, value) {\n            if (key && value && typeof key === 'string' && Array.isArray(value)) {\n                this._query['query'][key] = this._query['query'][key] || {};\n                this._query['query'][key][type] = this._query['query'][key][type] || [];\n                this._query['query'][key][type] = this._query['query'][key][type].concat(value);\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        };\n    },\n    exists: function exists(bool) {\n        return function (key) {\n            if (key && typeof key === 'string') {\n                this._query['query'][key] = this._query['query'][key] || {};\n                this._query['query'][key]['$exists'] = bool;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        };\n    },\n    logical: function logical(type) {\n        return function () {\n            var _query = [];\n            for (var i = 0, _i = arguments.length; i < _i; i++) {\n                if (arguments[i] instanceof Query && arguments[i]._query.query) {\n                    _query.push(arguments[i]._query.query);\n                } else if (_typeof(arguments[i]) === \"object\") {\n                    _query.push(arguments[i]);\n                }\n            }\n            if (this._query['query'][type]) {\n                this._query['query'][type] = this._query['query'][type].concat(_query);\n            } else {\n                this._query['query'][type] = _query;\n            }\n            return this;\n        };\n    },\n    sort: function sort(type) {\n        return function (key) {\n            if (key && typeof key === 'string') {\n                this._query[type] = key;\n                return this;\n            } else {\n                console.error(\"Argument should be a string.\");\n            }\n        };\n    },\n    pagination: function pagination(type) {\n        return function (value) {\n            if (typeof value === 'number') {\n                this._query[type] = value;\n                return this;\n            } else {\n                console.error(\"Argument should be a number.\");\n            }\n        };\n    }\n};\n\n/**\n * @class \n   Query  \n * @description\n * An initializer is responsible for creating Query object.Provides support for all search queries\n * @example\n * <caption>Query instance creation.</caption>\n * let Query = Contentstack.Stack().ContentType('example').Query();\n * let assetQuery =  Contentstack.Stack().Assets().Query();\n * @returns {Query}\n */\n\nvar Query = function (_Entry) {\n    _inherits(Query, _Entry);\n\n    function Query() {\n        _classCallCheck(this, Query);\n\n        var _this = _possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).call(this));\n\n        _this._query = _this._query || {};\n        _this._query['query'] = _this._query['query'] || {};\n        /**\n        * @method lessThan\n        * @memberOf Query\n        * @description Retrieves entries in which the value of a field is lesser than the provided value\n        * @param {String} key - uid of the field\n        * @param {*} value - Value used to match or compare\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.lessThan('created_at','2015-06-22').find()\n        *          data.then(function (result) {\n        *          // result content the data who's 'created_at date' is less than '2015-06-22'\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.lessThan = _extend.compare('$lt');\n\n        /**\n        * @method lessThanOrEqualTo\n        * @memberOf Query\n        * @description Retrieves entries in which the value of a field is lesser than or equal to the provided value.\n        * @param {String} key - uid of the field\n        * @param {*} value - Value used to match or compare\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.lessThanOrEqualTo('created_at','2015-06-22').find()\n        *          data.then(function (result) {\n        *          // result contain the data of entries where the 'created_at' date will be less than or equalto '2015-06-22'.\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.lessThanOrEqualTo = _extend.compare('$lte');\n        /**\n        * @method greaterThan\n        * @memberOf Query\n        * @description Retrieves entries in which the value for a field is greater than the provided value.\n        * @param {String} key - uid of the field\n        * @param {*} value -  value used to match or compare\n        * @example \n        *          let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.greaterThan('created_at','2015-03-12').find()\n        *                     data.then(function(result) {\n        *                       // result contains the data of entries where the 'created_at' date will be greaterthan '2015-06-22'\n        *                     },function (error) {\n        *                       // error function\n        *                     })\n        * @returns {Query}\n        * @instance\n        */\n        _this.greaterThan = _extend.compare('$gt');\n\n        /**\n         * @method greaterThanOrEqualTo\n         * @memberOf Query\n         * @description Retrieves entries in which the value for a field is greater than or equal to the provided value.\n         * @param {String} key - uid of the field \n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.greaterThanOrEqualTo('created_at','2015-03-12').find()\n         *          data.then(function(result) {\n         *          // result contains the data of entries where the 'created_at' date will be greaterThan or equalto '2015-06-22'\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.greaterThanOrEqualTo = _extend.compare('$gte');\n\n        /**\n         * @method notEqualTo\n         * @memberOf Query\n         * @description Retrieves entries in which the value for a field does not match the provided value.\n         * @param {String} key - uid of the field \n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.notEqualTo('title','Demo').find()\n         *          data.then(function(result) {\n         *            // ‘result’ contains the list of entries where value of the ‘title’ field will not be 'Demo'.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.notEqualTo = _extend.compare('$ne');\n\n        /**\n         * @method containedIn\n         * @memberOf Query\n         * @description Retrieve entries in which the value of a field matches with any of the provided array of values\n         * @param {String} key - uid of the field\n         * @param {*} value - Array of values that are to be used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.containedIn('title', ['Demo', 'Welcome']).find()\n         *          data.then(function(result) {\n         *          // ‘result’ contains the list of entries where value of the ‘title’ field will contain either 'Demo' or ‘Welcome’.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.containedIn = _extend.contained(true);\n\n        /**\n          * @method notContainedIn\n          * @memberOf Query\n          * @description Retrieve entries in which the value of a field does not match with any of the provided array of values.\n          * @param {String} key - uid of the field\n          * @param {Array} value - Array of values that are to be used to match or compare\n          * @example let blogQuery = Stack().ContentType('example').Query();\n          *          let data = blogQuery.notContainedIn('title', ['Demo', 'Welcome']).find()\n          *          data.then(function(result) {\n          *          // 'result' contains the list of entries where value of the title field should not be either \"Demo\" or ‘Welcome’\n          *       },function (error) {\n          *          // error function\n          *      })\n          * @returns {Query}\n          * @instance\n          */\n        _this.notContainedIn = _extend.contained(false);\n\n        /**\n        * @method exists \n        * @memberOf Query\n        * @description Retrieve entries if value of the field, mentioned in the condition, exists.\n        * @param {String} key - uid of the field\n        * @example blogQuery.exists('featured')\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.exists('featured').find()\n        *          data.then(function(result) {\n        *          // ‘result’ contains the list of entries in which \"featured\" exists.\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.exists = _extend.exists(true);\n\n        /**\n        * @method notExists\n        * @memberOf Query\n        * @description Retrieve entries if value of the field, mentioned in the condition, does not exists.\n        * @param {String} key - uid of the field\n        * @example blogQuery.notExists('featured')\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.notExists('featured').find()\n        *          data.then(function(result) {\n        *        // result is the list of non-existing’featured’\" data.\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.notExists = _extend.exists(false);\n\n        /**\n        * @method ascending\n        * @memberOf Query\n        * @description Sort fetched entries in the ascending order with respect to a specific field.\n        * @param {String} key - field uid based on which the ordering will be done\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.ascending('created_at').find()\n        *          data.then(function(result) {\n        *           // ‘result’ contains the list of entries which is sorted in ascending order on the basis of ‘created_at’. \n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.ascending = _extend.sort('asc');\n\n        /**\n         * @method descending\n         * @memberOf Query\n         * @description Sort fetched entries in the descending order with respect to a specific field\n         * @param {String} key - field uid based on which the ordering will be done.\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.descending('created_at').find()\n         *          data.then(function(result) {\n         *           // ‘result’ contains the list of entries which is sorted in descending order on the basis of ‘created_at’. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.descending = _extend.sort('desc');\n\n        /**\n        * @method beforeUid\n        * @memberOf Query\n        * @description Sort fetched entries in the descending order with respect to a specific field\n        * @param {String} uid - field uid based on which the ordering will be done.\n        * @example blogQuery.beforeUid('blt1234567890abcdef')\n        * @returns {Query}\n        * @instance\n        */\n        _this.beforeUid = _extend.sort('before_uid');\n\n        /**\n         * @method afterUid\n         * @memberOf Query\n         * @description This method provides only the entries after the specified entry id.\n         * @param {String} uid - uid of the entry\n         * @example blogQuery.afterUid('blt1234567890abcdef')\n         * @returns {Query}\n         * @instance\n         */\n        _this.afterUid = _extend.sort('after_uid');\n\n        /**\n        * @method skip\n        * @memberOf Query\n        * @description Skips at specific number of entries.\n        * @param {Number} skip - number of entries to be skipped\n        * @example blogQuery.skip(5)\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.skip(5).find()\n        *          data.then(function(result) {\n        *          // result contains the list of data which is sorted in descending order on 'created_at' bases. \n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.skip = _extend.pagination('skip');\n\n        /**\n        * @method limit\n        * @memberOf Query\n        * @description Returns a specific number of entries based on the set limit\n        * @param {Number} limit - maximum number of entries to be returned\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.limit(10).find()\n        *          data.then(function(result) {\n        *          // result contains the limited number of entries\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.limit = _extend.pagination('limit');\n\n        /**\n        * @method or\n        * @memberOf Query\n        * @description Retrieves entries that satisfy at least one of the given conditions\n        * @param {object} queries - array of Query objects or raw queries\n        * @example\n        * <caption> .or with Query instances</caption>\n        * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').find()\n        * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).find()\n        * blogQuery.or(Query1, Query2)\n        * @example\n        * <caption> .or with raw queries</caption>\n        * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()\n        * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()\n        * blogQuery.or(Query1, Query2)\n        * @returns {Query}\n        * @instance\n        */\n        _this.or = _extend.logical('$or');\n\n        /**\n         * @method and\n         * @memberOf Query\n         * @description Retrieve entries that satisfy all the provided conditions.\n         * @param {object} queries - array of query objects or raw queries.\n         * @example\n         * <caption> .and with Query instances</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo')\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10)\n         * blogQuery.and(Query1, Query2)\n         * @example\n         * <caption> .and with raw queries</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()\n         * blogQuery.and(Query1, Query2)\n         * @returns {Query}\n         * @instance\n         */\n        _this.and = _extend.logical('$and');\n        return _this;\n    }\n\n    _createClass(Query, [{\n        key: 'equalTo',\n        value: function equalTo(key, value) {\n            if (key && typeof key === 'string') {\n                this._query['query'][key] = value;\n\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @memberOf Query\n         * @description Retrieve entries in which a specific field satisfies the value provided\n         * @param {String} key - uid of the field\n         * @param {*} value - value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.where('title','Demo').find()\n         *          data.then(function(result) {\n         *            // ‘result’ contains the list of entries where value of ‘title’ is equal to ‘Demo’. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'where',\n        value: function where(key, value) {\n            if (key && typeof key === 'string') {\n                this._query['query'][key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method count\n         * @memberOf Query\n         * @description Returns the total number of entries\n         * @example blogQuery.count()\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.count().find()\n         *          data.then(function(result) {\n         *           // ‘result’ contains the total count. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'count',\n        value: function count() {\n            var host = this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version,\n                url = this.type && this.type === 'asset' ? host + this.config.urls.assets : host + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;\n            this._query['count'] = true;\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: url,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            return this;\n        }\n\n        /**\n         * @method query\n         * @memberOf Query\n         * @description Retrieve entries based on raw queries\n         * @param {object} query - RAW (JSON) queries \n         * @returns {Query}\n         * @instance\n         * @example \n         * let blogQuery = Stack().ContentType('example').Query();\n         * let data = blogQuery.query({\"brand\": {\"$nin_query\": {\"title\": \"Apple Inc.\"}}}).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         */\n\n    }, {\n        key: 'query',\n        value: function query(_query2) {\n            if ((typeof _query2 === 'undefined' ? 'undefined' : _typeof(_query2)) === \"object\") {\n                this._query['query'] = Utils.mergeDeep(this._query['query'], _query2);\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters\");\n            }\n        }\n\n        /**\n         * @method referenceIn\n         * @memberOf Query\n         * @description Retrieve entries that satisfy the query conditions made on referenced fields.\n         * @param {Query} query - RAW (JSON) queries \n         * @returns {Query}\n         * @instance\n         * @example \n         * <caption> referenceIn with Query instances</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')\n         * let data = blogQuery.referenceIn(\"brand\", Query).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         * \n         * @example \n         * <caption> referenceIn with raw queries</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let data = blogQuery.referenceIn(\"brand\", {'title': 'Demo'}).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         */\n\n    }, {\n        key: 'referenceIn',\n        value: function referenceIn(key, query) {\n            var _query = {};\n            if (query instanceof Query && query._query.query) {\n                _query[\"$in_query\"] = query._query.query;\n            } else if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === \"object\") {\n                _query[\"$in_query\"] = query;\n            }\n            if (this._query['query'][key]) {\n                this._query['query'][key] = this._query['query'][key].concat(_query);\n            } else {\n                this._query['query'][key] = _query;\n            }\n            return this;\n        }\n\n        /**\n         * @method referenceNotIn\n         * @memberOf Query\n         * @description Retrieve entries that does not satisfy the query conditions made on referenced fields.\n         * @param {Query} query - RAW (JSON) queries \n         * @returns {Query}\n         * @instance\n         * @example \n         * <caption> referenceNotIn with Query instances</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let data = blogQuery.referenceNotIn(\"brand\", {'title': 'Demo'}).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         * \n         * @example \n         * <caption> referenceNotIn with raw queries</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')\n         * let data = blogQuery.referenceNotIn(\"brand\", Query).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         */\n\n    }, {\n        key: 'referenceNotIn',\n        value: function referenceNotIn(key, query) {\n            var _query = {};\n            if (query instanceof Query && query._query.query) {\n                _query[\"$nin_query\"] = query._query.query;\n            } else if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === \"object\") {\n                _query[\"$nin_query\"] = query;\n            }\n            if (this._query['query'][key]) {\n                this._query['query'][key] = this._query['query'][key].concat(_query);\n            } else {\n                this._query['query'][key] = _query;\n            }\n            return this;\n        }\n\n        /**\n         * @method tags\n         * @memberOf Query\n         * @description Retrieves entries based on the provided tags\n         * @param {Array} values - tags\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.tags(['technology', 'business']).find()\n         *          data.then(function(result) {\n         *        // ‘result’ contains list of entries which have tags \"’technology’\" and ‘\"business’\".\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'tags',\n        value: function tags(values) {\n            if (Array.isArray(values)) {\n                this._query['tags'] = values;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters\");\n            }\n        }\n\n        /**\n         * @method includeReferenceContentTypeUid\n         * @memberOf Query\n         * @description  This method also includes the content type UIDs of the referenced entries returned in the response.\n         * @example Stack.ContentType(\"contentType_uid\").Query().includeReferenceContentTypeUID().find()\n         * @example \n         * let blogQuery = Stack.ContentType(\"contentType_uid\").Query();\n         *          let data = blogQuery.includeReferenceContentTypeUID().find()\n         *          data.then(function(result) {\n         *         // ‘result’ contains a list of entries in which content type UIDs is present. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'includeReferenceContentTypeUID',\n        value: function includeReferenceContentTypeUID() {\n            this._query['include_reference_content_type_uid'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeCount\n         * @memberOf Query\n         * @description Includes the total number of entries returned in the response.\n         * @example blogQuery.includeCount()\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.includeCount().find()\n         *          data.then(function(result) {\n         *         // ‘result’ contains a list of entries in which count of object is present at array[1] position. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'includeCount',\n        value: function includeCount() {\n            this._query['include_count'] = true;\n            return this;\n        }\n\n        /**\n         * @method addParam\n         * @description Includes query parameters in your queries.\n         * @memberOf Query\n         * @example var data = blogQuery.addParam('include_count', 'true').fetch()\n         *      data.then(function (result) {\n         *          // 'result' is an object which content the data including count in json object form\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'addParam',\n        value: function addParam(key, value) {\n            if (key && value && typeof key === 'string' && typeof value === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method getQuery\n         * @memberOf Query\n         * @description Returns the raw (JSON) query based on the filters applied on Query object.\n         * @example Stack.ContentType('contentType_uid').Query().where('title','Demo').getQuery().find()\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'getQuery',\n        value: function getQuery() {\n            return this._query.query || {};\n        }\n\n        /**\n         * @method regex\n         * @memberOf Query\n         * @description Retrieve entries that match the provided regular expressions\n         * @param {String} key - uid of the field\n         * @param {*} value - value used to match or compare\n         * @param {String} [options] - match or compare value in entry\n         * @example\n         * <caption> .regex without options</caption>\n         * blogQuery.regex('title','^Demo')\n         * @example\n         * <caption> .regex with options</caption>\n         * blogQuery.regex('title','^Demo', 'i')\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'regex',\n        value: function regex(key, value, options) {\n            if (key && value && typeof key === 'string' && typeof value === 'string') {\n                this._query['query'][key] = {\n                    $regex: value\n                };\n                if (options) this._query['query'][key]['$options'] = options;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method search\n         * @memberOf Query\n         * @description Retrieve entries that have fields which match the provided search value.\n         * @param {string} value - value to search in entries\n         * @example blogQuery.search('Welcome to demo')\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.search('welcome to demo').find()\n         *          data.then(function(result) {\n         *         // ‘result’ contains the object that possess the text \"’welcome to demo’\".\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'search',\n        value: function search(value) {\n            if (value && typeof value === 'string') {\n                this._query['typeahead'] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method find\n         * @memberOf Query\n         * @description Retrieves entries that satisfied the specified query\n         * @example let blogQuery = Stack().ContentType('example').Query().find();\n         *          blogQuery.then(function(result) {\n         *          // result contains the list of object. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * blogQuery.find()\n         * @example\n         * let blogQuery = Stack.ContentType(contentTypeUid).Query().find({\n         *        \n         *      });\n         * blogQuery.then(function(result) {\n         *          // result contains the list of object. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * blogQuery.find()\n         * @returns {promise}\n         * @instance\n         */\n\n    }, {\n        key: 'find',\n        value: function find(fetchOptions) {\n            var host = this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version,\n                url = this.type && this.type === 'asset' ? host + this.config.urls.assets : host + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: url,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions, fetchOptions);\n            return Utils.sendRequest(this, options);\n        }\n\n        /**\n        * @method findOne\n        * @memberOf Query\n        * @deprecated since verion 3.3.0\n        * @description Retrieve a single entry from the result\n        * @example let blogQuery = Stack().ContentType('example').Query().findOne();\n        *          blogQuery.then(function(result) {\n        *          // result contains the single item object. \n        *       },function (error) {\n        *          // error function\n        *      })\n        * blogQuery.findOne()\n        * @returns {promise}\n        * @instance\n        */\n\n    }, {\n        key: 'findOne',\n        value: function findOne() {\n            var host = this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version,\n                url = this.type && this.type === 'asset' ? host + this.config.urls.assets : host + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;\n            this.singleEntry = true;\n            this._query.limit = 1;\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: url,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions);\n            return Utils.sendRequest(this, options);\n        }\n    }]);\n\n    return Query;\n}(_entry2.default);\n\nexports.default = Query;\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/query.js?");

/***/ }),

/***/ "./src/core/modules/result.js":
/*!************************************!*\
  !*** ./src/core/modules/result.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ../lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class Result\n * @summary Creates an instance of `Result`.\n * @description An initializer is responsible for creating Result object.\n * @param {Object} object - API result object\n * @example\n * blogEntry.then(function (result) {\n *      // sucess function\n * },function (error) {\n *      // error function\n * })\n * @example\n * assetQuery.then(function (result) {\n *      // sucess function\n * },function (error) {\n *      // error function\n * })\n * @returns {Result}\n * @instance \n */\nvar Result = function () {\n    function Result(object) {\n        _classCallCheck(this, Result);\n\n        if (object) {\n            this.object = function () {\n                return object;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * @method toJSON\n     * @memberOf Result\n     * @description Converts `Result` to plain javascript object.\n     * @example\n     * blogEntry.then(function (result) {\n     *      result = result[0][0].toJSON()\n     * },function (error) {\n     *      // error function\n     * })\n     * @example\n     * assetQuery.then(function (result) {\n     *      result = result[0][0].toJSON()\n     * },function (error) {\n     *      // error function\n     * })\n     * @returns {object}\n     * @instance \n     */\n\n\n    _createClass(Result, [{\n        key: 'toJSON',\n        value: function toJSON() {\n            return this.object() ? Utils.mergeDeep(JSON.parse(JSON.stringify({})), this.object()) : null;\n        }\n\n        /**\n          * @method get\n          * @memberOf Result\n          * @description Retrieve details of a field based on the UID provided\n          * @param field_uid uid of the field\n          * @example\n          * blogEntry.then(function (result) {\n          *      let value = result[0][0].get(field_uid)\n          * },function (error) {\n          *      // error function\n          * })\n          * @example\n          * assetQuery.then(function (result) {\n          *      let value = result[0][0].get(field_uid)\n          * },function (error) {\n          *      // error function\n          * })\n          * @returns {promise}\n          * @instance  \n          */\n\n    }, {\n        key: 'get',\n        value: function get(key) {\n            if (this.object() && key) {\n                var fields = key.split('.');\n                var value = fields.reduce(function (prev, field) {\n                    return prev[field];\n                }, this.object());\n                return value;\n            }\n            return;\n        }\n\n        /**\n        * @method getDownloadUrl\n        * @memberOf Result\n        * @description Retrieves the download URL based on the disposition value.\n        * @param {String} string - disposition value\n        * @example\n        * assetQuery.then(function (result) {\n        *      let value = result[0][0].getDownloadUrl(disposition_value)\n        * },function (error) {\n        *      // error function\n        * })\n        * @returns {Object}\n        * @instance    \n        */\n\n    }, {\n        key: 'getDownloadUrl',\n        value: function getDownloadUrl(disposition) {\n            if (this.object()) {\n                var url = this.object().url ? this.object().url : null,\n                    _disposition = disposition && typeof disposition === 'string' ? disposition : 'attachment';\n                return url ? url + '?disposition=' + _disposition : null;\n            }\n        }\n    }]);\n\n    return Result;\n}();\n\nmodule.exports = function (object) {\n    return new Result(object);\n};\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/result.js?");

/***/ }),

/***/ "./src/core/stack.js":
/*!***************************!*\
  !*** ./src/core/stack.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _config = __webpack_require__(/*! ../../config */ \"./config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _utils = __webpack_require__(/*! ./lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _entry = __webpack_require__(/*! ./modules/entry */ \"./src/core/modules/entry.js\");\n\nvar _entry2 = _interopRequireDefault(_entry);\n\nvar _assets = __webpack_require__(/*! ./modules/assets */ \"./src/core/modules/assets.js\");\n\nvar _assets2 = _interopRequireDefault(_assets);\n\nvar _query = __webpack_require__(/*! ./modules/query */ \"./src/core/modules/query.js\");\n\nvar _query2 = _interopRequireDefault(_query);\n\nvar _request = __webpack_require__(/*! ./lib/request */ \"./src/core/lib/request.js\");\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _cache = __webpack_require__(/*! ./cache */ \"./src/core/cache.js\");\n\nvar cache = _interopRequireWildcard(_cache);\n\nvar _index = __webpack_require__(/*! ./cache-provider/index */ \"./src/core/cache-provider/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar errorRetry = [408, 429];\n\n/**\n     * @class \n        Stack \n     * @description Initialize an instance of ‘Stack’\n     * @param api_key - Stack API Key.\n     * @param delivery_token - Stack Delivery token.\n     * @param environment - Stack Environment name.\n     * @param region - DB region for Stack.\n     * @param fetchOptions - Custom setting for the request.\n     * @param fetchOptions.timeout - Set timeout for the request.\n     * @param fetchOptions.retryLimit - The number of retries before failure. Default is 5\n     * @param fetchOptions.retryDelay - The number of ms to use for operation retries. Default is 300ms\n     * @param fetchOptions.retryCondition - A function to determine if the error can be retried. Default retry is on status codes 408, 429, and greter than equal to 500.\n     * @param fetchOptions.retryDelayOptions.base - The base number of milliseconds to use in the exponential backoff for operation retries.\n     * @param fetchOptions.retryDelayOptions.customBackoff - A custom function that accepts a retry count and error and returns the amount of time to delay in milliseconds.\n     * @example\n     * var Stack = Contentstack.Stack({\n     *      'api_key':'api_key',\n     *      'delivery_token':'delivery_token',\n     *      'environment':'environment_name',\n     *      'region': 'us',\n     *      'fetchOptions': {\n     *       \n     *      }\n     * });\n     * \n     * @example\n     * var Stack = Contentstack.Stack('api_key', 'access_token', 'environment', {\n     * \n     * });\n     * \n     * @example\n     * // For Setting the European Region:\n     * // If you want to set and use European region, refer to the code below:\n     * const Stack = Contentstack.Stack(\"api_key\", \"delivery_token\", \"environment_name\", Contentstack.Region.EU);\n     * \n     * @returns {Stack}\n     * @instance\n     */\n\nvar Stack = function () {\n    function Stack() {\n        _classCallCheck(this, Stack);\n\n        this.fetchOptions = {\n            retryLimit: 5,\n            retryCondition: function retryCondition(error) {\n                if (errorRetry.includes(error.status)) {\n                    return true;\n                }\n                return false;\n            }\n        };\n        this.config = Object.assign({}, _config2.default);\n\n        for (var _len = arguments.length, stack_arguments = Array(_len), _key = 0; _key < _len; _key++) {\n            stack_arguments[_key] = arguments[_key];\n        }\n\n        if (stack_arguments[0].region && stack_arguments[0].region !== undefined && stack_arguments[0].region !== \"us\") {\n            this.config['host'] = stack_arguments[0].region + \"-\" + \"cdn.contentstack.com\";\n        }\n\n        if (stack_arguments[0].fetchOptions && stack_arguments[0].fetchOptions !== undefined) {\n            this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[0].fetchOptions);\n        }\n\n        this.cachePolicy = _index2.default.policies.IGNORE_CACHE;\n        this.provider = _index2.default.providers('localstorage');\n\n        switch (stack_arguments.length) {\n            case 1:\n                if (_typeof(stack_arguments[0]) === \"object\" && typeof stack_arguments[0].api_key === \"string\" && typeof stack_arguments[0].delivery_token === \"string\" && typeof stack_arguments[0].environment === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0].api_key,\n                        access_token: stack_arguments[0].delivery_token\n                    };\n                    this.environment = stack_arguments[0].environment;\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid object parameters. The specified API Key, Delivery Token, or Environment Name is invalid.\");\n                }\n            case 3:\n                if (typeof stack_arguments[0] === \"string\" && typeof stack_arguments[1] === \"string\" && typeof stack_arguments[2] === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0],\n                        access_token: stack_arguments[1]\n                    };\n                    this.environment = stack_arguments[2];\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid string parameters.\");\n                }\n            case 4:\n                if (typeof stack_arguments[0] === \"string\" && typeof stack_arguments[1] === \"string\" && typeof stack_arguments[2] === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0],\n                        access_token: stack_arguments[1]\n                    };\n                    this.environment = stack_arguments[2];\n                } else {\n                    console.error(\"Kindly provide valid string parameters.\");\n                }\n                if (stack_arguments[3]) {\n                    if (typeof stack_arguments[3] === \"string\" && stack_arguments[3] !== undefined && stack_arguments[3] !== \"us\") {\n                        this.config['host'] = stack_arguments[3] + \"-\" + \"cdn.contentstack.com\";\n                    } else if (_typeof(stack_arguments[3]) === 'object') {\n                        this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[3]);\n                    }\n                }\n                return this;\n            case 5:\n                if (typeof stack_arguments[0] === \"string\" && typeof stack_arguments[1] === \"string\" && typeof stack_arguments[2] === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0],\n                        access_token: stack_arguments[1]\n                    };\n                    this.environment = stack_arguments[2];\n                } else {\n                    console.error(\"Kindly provide valid string parameters.\");\n                }\n\n                if (stack_arguments[3]) {\n                    if (typeof stack_arguments[3] === \"string\" && stack_arguments[3] !== undefined && stack_arguments[3] !== \"us\") {\n                        this.config['host'] = stack_arguments[3] + \"-\" + \"cdn.contentstack.com\";\n                    } else if (_typeof(stack_arguments[3]) === 'object') {\n                        this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[3]);\n                    }\n                }\n                if (stack_arguments[4] && _typeof(stack_arguments[4]) === 'object') {\n                    this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[4]);\n                }\n                return this;\n            default:\n                console.error(\"Kindly provide valid parameters to initialize the Contentstack javascript-SDK Stack.\");\n        }\n    }\n\n    /**\n     * @method setPort\n     * @memberOf Stack\n     * @description Sets the port of the host\n     * @param {Number} port - Port Number\n     * @return {Stack}\n     * @instance\n     * */\n\n\n    _createClass(Stack, [{\n        key: 'setPort',\n        value: function setPort(port) {\n            if (typeof port === \"number\") this.config.port = port;\n            return this;\n        }\n\n        /**\n         * @method setProtocol\n         * @memberOf Stack\n         * @description Sets the protocol for the host\n         * @param {String} protocol - http/https protocol\n         * @return {Stack}\n         * @instance\n         * */\n\n    }, {\n        key: 'setProtocol',\n        value: function setProtocol(protocol) {\n            if (typeof protocol === \"string\" && ~[\"https\", \"http\"].indexOf(protocol)) this.config.protocol = protocol;\n            return this;\n        }\n\n        /**\n         * @method setHost\n         * @memberOf Stack\n         * @description Sets the host of the API server\n         * @param {String} host - valid ip or host\n         * @return {Stack}\n         * @instance\n         * */\n\n    }, {\n        key: 'setHost',\n        value: function setHost(host) {\n            if (typeof host === \"string\" && host) this.config.host = host;\n            return this;\n        }\n\n        /**\n         * @method setCachePolicy\n         * @memberOf Stack\n         * @description Allows you to set cache policies\n         * @param {Constant} [key=ONLY_NETWORK] - Cache policy to be applied on Stack or Query.\n         * @example\n         * Stack.setCachePolicy(Contentstack.CachePolicy.IGNORE_CACHE)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.ONLY_NETWORK)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_ELSE_NETWORK)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.NETWORK_ELSE_CACHE)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_THEN_NETWORK)\n         * @returns {Stack}\n         * @instance\n         */\n\n    }, {\n        key: 'setCachePolicy',\n        value: function setCachePolicy(policy) {\n            if (typeof policy === 'number' && policy >= -1 && policy < 4) {\n                if (!this._query) {\n                    this.cachePolicy = policy;\n                } else {\n                    this.queryCachePolicy = policy;\n                }\n            } else {\n                console.error(\"Kindly provide the valid policy\");\n            }\n            return this;\n        }\n\n        /**\n        * @method setCacheProvider\n        * @memberOf Stack\n        * @description Allows you to set an object of the cache provider\n        * @example\n        * Stack\n        *      .setCacheProvider({\n        *          get: function (key, callback) {\n        *              // custom logic\n        *          },\n        *          set: function (key, value, callback) {\n        *              // custom logic\n        *          }\n        *      });\n        * @returns {Stack}\n        * @instance\n        */\n\n    }, {\n        key: 'setCacheProvider',\n        value: function setCacheProvider(provider) {\n            if (provider && (typeof provider === 'undefined' ? 'undefined' : _typeof(provider)) === 'object') {\n                this.provider = provider;\n            }\n            return this;\n        }\n\n        /**\n         * @method clearByQuery\n         * @memberOf Stack\n         * @description 'clearByQuery' function to clear the query from the cache.\n         * @example\n         * Stack.clearQuery(query, callback);\n         * @returns {Stack}\n         * @instance\n         */\n\n    }, {\n        key: 'clearByQuery',\n        value: function clearByQuery() {\n            if (this.provider && typeof this.provider.clearByQuery === 'function') {\n                return this.provider.clearByQuery.apply(this.provider, arguments);\n            }\n        }\n\n        /**\n         * @method clearByContentType\n         * @memberOf Stack\n         * @description 'clearByContentType' function to clear the query from the cache by specified content type.\n         * @example\n         * Stack.clearByContentType(content_type_uid, callback);\n         * Stack.clearByContentType(content_type_uid, language_uid, callback);\n         * @returns {Stack}\n         * @instance\n         */\n\n    }, {\n        key: 'clearByContentType',\n        value: function clearByContentType() {\n            if (this.provider && typeof this.provider.clearByContentType === 'function') {\n                return this.provider.clearByContentType.apply(this.provider, arguments);\n            }\n        }\n\n        /**\n         * @method clearAll\n         * @memberOf Stack\n         * @description 'clearAll' function to clear all the queries from cache.\n         * @example\n         * Stack.clearAll(callback);\n         * @returns {Stack}\n         * @instance   \n         */\n\n    }, {\n        key: 'clearAll',\n        value: function clearAll() {\n            if (this.provider && typeof this.provider.clearAll === 'function') {\n                return this.provider.clearAll.apply(this.provider, arguments);\n            }\n        }\n\n        /**\n          * @method getCacheProvider\n          * @memberOf Stack\n          * @description Returns the currently set object of 'CacheProvider'\n          * @example Stack.getCacheProvider();\n          * @returns {object}\n          * @instance\n          */\n\n    }, {\n        key: 'getCacheProvider',\n        value: function getCacheProvider() {\n            return this.provider;\n        }\n\n        /**\n          * @method ContentType\n          * @memberOf Stack\n          * @description Set the content type of which you want to retrieve the entries\n          * @param {String} [content_type_uid] - uid of the existing content type\n          * @example \n          * let data = Stack.ContentType('blog').Query().toJSON().find()\n          *      data\n          *      .then(function(result) {\n          *           // 'result' content the list of entries of particular content type blog.       \n          *      }, function(error) {\n          *           // error function\n          *      })\n          * @returns {Stack}\n          * @instance\n          */\n\n    }, {\n        key: 'ContentType',\n        value: function ContentType(uid) {\n            if (uid && typeof uid === 'string') {\n                this.content_type_uid = uid;\n                this.type = \"contentType\";\n            }\n            return this;\n        }\n\n        /**\n            * @method Entry\n            * @memberOf ContentType\n            * @param {String} uid - uid of the entry \n            * @description An initializer is responsible for creating Entry object\n            * @returns {Entry}\n            * @instance \n            */\n\n    }, {\n        key: 'Entry',\n        value: function Entry(uid) {\n            var entry = new _entry2.default();\n            if (uid && typeof uid === \"string\") {\n                entry.entry_uid = uid;\n            }\n            return Utils.merge(entry, this);\n        }\n\n        /**\n        * @method fetch\n        * @memberOf ContentType\n        * @description This method returns the complete information of a specific content type.\n        * @example\n        * let single_contenttype = Stack.ContentType(content_type_uid).fetch()\n        *    single_contenttype\n        *    .then(function(result) {\n        *      // 'result' is a single contentType information.       \n        *     }).catch((error) => {\n        *        console.log(error)\n        *  });\n        * @returns {promise}\n        * @instance \n        */\n\n    }, {\n        key: 'fetch',\n        value: function fetch(fetchOptions) {\n            var result = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid,\n                body: {\n                    _method: 'GET',\n                    environment: this.environment\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions, fetchOptions);\n            return (0, _request2.default)(result, options);\n        }\n\n        /**\n           * @method Assets\n           * @memberOf Stack\n           * @param {String} uid - uid of the asset \n           * @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.\n           * @example \n           * // Retrieves all assets\n           * let data = Stack.Assets().Query().toJSON().find()\n           *      data\n           *      .then(function(result) {\n           *          // All the asset with limit of 100\n           *          // Use skip and limit functions to paginate\n           *          // ‘result’ will display all assets present in stack       \n           *      }, function(error) {\n           *           // error function\n           *      })\n           * \n           * @example \n           * let data = Stack.Assets('bltsomething123').toJSON().fetch()\n           *      data\n           *        .then(function(result) {\n           *           // ‘result’ is a single asset object of specified uid       \n           *      }, function(error) {\n           *           // error function\n           *      })\n           * \n           * @returns {Assets}\n           * @instance \n           */\n\n    }, {\n        key: 'Assets',\n        value: function Assets(uid) {\n            this.type = 'asset';\n            if (uid && typeof uid === \"string\") {\n                var asset = new _assets2.default();\n                asset.asset_uid = uid;\n                return Utils.merge(asset, this);\n            }\n            return this;\n        }\n\n        /**\n            * @method Query\n            * @memberOf Stack\n            * @description An initializer is responsible for creating Query object.Provides support for all search queries\n            * @returns {Query}\n            * @instance  \n            */\n\n    }, {\n        key: 'Query',\n        value: function Query() {\n            var query = new _query2.default();\n            return Utils.merge(query, this);\n        }\n\n        /**\n          * @method getLastActivites\n          * @memberOf Stack\n          * @description getLastActivites get all the ContentTypes whose last activity updated.\n          * @example Stack.getLastActivites()\n          * @example \n          * let data = Stack.getLastActivites().toJSON().fetch()\n          *      data\n          *      .then(function(result) {\n          *           // 'result' is list of contentTypes whose last activity updated.       \n          *      }, function(error) {\n          *           // error function\n          *      })\n          * @returns {promise}\n          * @instance\n          */\n\n    }, {\n        key: 'getLastActivities',\n        value: function getLastActivities() {\n            var query = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,\n                body: {\n                    _method: 'GET',\n                    only_last_activity: true,\n                    environment: this.environment\n                }\n            };\n            return (0, _request2.default)(query, this.fetchOptions);\n        }\n\n        /**\n        * @method getContentTypes\n        * @memberOf Stack\n        * @param {String} param - Query on contentTypes\n        * @description This method returns comprehensive information of all the content types of a particular stack in your account.\n        * @example \n        * let data = Stack.getContentTypes({\"include_global_field_schema\": true})\n        *      data\n        *      .then(function(result) {\n        *           // 'result' is list of contentTypes.       \n        *      }, function(error) {\n        *           // error function\n        *      })\n        * @returns {promise}\n        * @instance\n        */\n\n    }, {\n        key: 'getContentTypes',\n        value: function getContentTypes() {\n            var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var query = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,\n                body: {\n                    _method: 'GET',\n                    environment: this.environment\n                }\n            };\n            if (param && param !== undefined) {\n                for (var key in param) {\n                    query.body[key] = param[key];\n                }\n            }\n            return (0, _request2.default)(query, this.fetchOptions);\n        }\n\n        /**\n         * @method sync\n         * @memberOf Stack\n         * @description Syncs your Contentstack data with your app and ensures that the data is always up-to-date by providing delta updates\n         * @param {object} params - params is an object that supports ‘locale’, ‘start_date’, ‘content_type_uid’, and ‘type’ queries.\n         * @example \n         * Stack.sync({'init': true})        // For initializing sync\n         * @example \n         * Stack.sync({'init': true, 'locale': 'en-us'})     //For initializing sync with entries of a specific locale\n         * @example \n         * Stack.sync({'init': true, 'start_date': '2018-10-22'})    //For initializing sync with entries published after a specific date\n         * @example \n         * Stack.sync({'init': true, 'content_type_uid': 'session'})   //For initializing sync with entries of a specific content type\n         * @example \n         * Stack.sync({'init': true, 'type': 'entry_published'})   //Use the type parameter to get a specific type of content.Supports 'asset_published', 'entry_published', 'asset_unpublished', 'entry_unpublished', 'asset_deleted', 'entry_deleted', 'content_type_deleted'.\n         * @example \n         * Stack.sync({'pagination_token': '<btlsomething>'})    // For fetching the next batch of entries using pagination token\n         * @example \n         * Stack.sync({'sync_token': '<btlsomething>'})    // For performing subsequent sync after initial sync\n         * @returns {promise}\n         * @instance\n         */\n\n    }, {\n        key: 'sync',\n        value: function sync(params, fetchOptions) {\n            this._query = {};\n            this._query = Object.assign(this._query, params);\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.sync,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions, fetchOptions);\n            return Utils.sendRequest(this, options);\n        }\n\n        /**\n         * @method imageTransform\n         * @memberOf Stack\n         * @description Performs transformations on images of mentioned url based on transformation parameters \n         * @param {String} url - Image url on which transformations need to be applied.\n         * @param {String} params - Object with transformation parameters\n         * @example\n         * Stack.imageTransform(imageURL, {height: 100, width: 200, disable: \"upscale\"});\n         * @example\n         * Stack.imageTransform(imageURL, {crop: \"150,100\"});\n         * @example\n         * Stack.imageTransform(imageURL, {format: \"png\", crop: \"150,100\"});\n         * @returns {string} [Image url with transformation parameters.]\n         * @instance\n         */\n\n    }, {\n        key: 'imageTransform',\n        value: function imageTransform(url, params) {\n            if (url && typeof url === \"string\" && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) === \"object\" && params.length === undefined) {\n                var queryParams = [];\n                for (var operation in params) {\n                    queryParams.push(operation + '=' + params[operation]);\n                }\n                url += url.indexOf(\"?\") <= -1 ? \"?\" + queryParams.join('&') : \"&\" + queryParams.join('&');\n            }\n\n            return url;\n        }\n    }]);\n\n    return Stack;\n}();\n\nexports.default = Stack;\n\n//# sourceURL=webpack://Contentstack/./src/core/stack.js?");

/***/ }),

/***/ "./src/runtime/react-native/http.js":
/*!******************************************!*\
  !*** ./src/runtime/react-native/http.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = fetch;\n\n//# sourceURL=webpack://Contentstack/./src/runtime/react-native/http.js?");

/***/ }),

/***/ "./src/runtime/react-native/localstorage.js":
/*!**************************************************!*\
  !*** ./src/runtime/react-native/localstorage.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _localStorage = __webpack_require__(/*! localStorage */ \"./node_modules/localStorage/lib/localStorage.js\");\n\nvar _localStorage2 = _interopRequireDefault(_localStorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _localStorage2.default;\n\n//# sourceURL=webpack://Contentstack/./src/runtime/react-native/localstorage.js?");

/***/ })

/******/ });